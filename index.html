<!DOCTYPE html>
<html lang="zh-CN">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>Milthm è°±é¢æ’­æ”¾å™¨</title>
   <style>
       :root {
           --bg: #1a1a1a;
           --panel: #252525;
           --text: #e0e0e0;
           --accent: #4a90e2;
           --border: #333;
       }

       body {
           margin: 0;
           overflow: hidden;
           background-color: var(--bg);
           color: var(--text);
           font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
           display: flex;
           justify-content: center;
           align-items: center;
           height: 100vh;
           width: 100vw;
       }

       /* åˆå§‹åŠ è½½ç•Œé¢ */
       #loading-screen {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           z-index: 10;
           background: var(--bg);
           transition: opacity 0.3s;
       }

       /* è®¾ç½®é¢æ¿ */
       #setup-panel {
           background: var(--panel);
           padding: 2rem;
           border-radius: 8px;
           box-shadow: 0 4px 20px rgba(0,0,0,0.5);
           width: 90%;
           max-width: 500px;
           display: flex;
           flex-direction: column;
           gap: 1rem;
           z-index: 20;
       }

       h2 {
           margin: 0 0 0.5rem 0;
           font-weight: 400;
           text-align: center;
           color: #fff;
       }

       .input-group {
           display: flex;
           flex-direction: column;
           gap: 0.5rem;
       }

       label {
           font-size: 0.9rem;
           color: #aaa;
       }

       input[type="file"] {
           display: none;
       }

       .file-btn {
           background: var(--bg);
           border: 1px solid var(--border);
           color: var(--text);
           padding: 10px;
           border-radius: 4px;
           cursor: pointer;
           text-align: center;
           transition: background 0.2s;
           overflow: hidden;
           text-overflow: ellipsis;
           white-space: nowrap;
       }

       .file-btn:hover {
           background: #333;
       }

       .file-btn.active {
           border-color: var(--accent);
           color: var(--accent);
       }

       .options-row {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-top: 0.5rem;
       }

       .checkbox-wrapper {
           display: flex;
           align-items: center;
           gap: 8px;
           cursor: pointer;
       }

       input[type="checkbox"] {
           width: 18px;
           height: 18px;
           accent-color: var(--accent);
           cursor: pointer;
       }

       .btn-primary {
           background: var(--accent);
           color: white;
           border: none;
           padding: 12px;
           border-radius: 4px;
           font-size: 1rem;
           cursor: pointer;
           margin-top: 1rem;
           transition: filter 0.2s;
       }

       .btn-primary:hover {
           filter: brightness(1.1);
       }

       .btn-primary:disabled {
           background: #555;
           cursor: not-allowed;
           filter: none;
       }

       /* æ¸¸æˆç”»å¸ƒ */
       #main-canvas {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           z-index: 1;
           display: none; /* åˆå§‹éšè— */
       }

       /* æ¸¸æˆå†…æ§åˆ¶æ  */
       #game-controls {
           position: absolute;
           top: 10px;
           right: 10px;
           z-index: 30;
           display: none;
           gap: 10px;
       }

       .icon-btn {
           background: rgba(0, 0, 0, 0.6);
           border: 1px solid rgba(255, 255, 255, 0.2);
           color: white;
           width: 40px;
           height: 40px;
           border-radius: 50%;
           cursor: pointer;
           display: flex;
           align-items: center;
           justify-content: center;
           font-size: 18px;
           backdrop-filter: blur(4px);
           transition: background 0.2s;
       }

       .icon-btn:hover {
           background: rgba(255, 255, 255, 0.2);
       }

       #status-msg {
           color: #ff6b6b;
           font-size: 0.85rem;
           text-align: center;
           min-height: 1.2em;
       }

       /* æ¸¸æˆåŠ è½½é®ç½© */
       #game-loading-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.9);
           display: none;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           z-index: 25;
           color: white;
       }

       .spinner {
           width: 50px;
           height: 50px;
           border: 4px solid rgba(255, 255, 255, 0.3);
           border-top: 4px solid var(--accent);
           border-radius: 50%;
           animation: spin 1s linear infinite;
           margin-bottom: 20px;
       }

       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }

       .loading-text {
           font-size: 1.2rem;
           color: #ccc;
       }

       /* Levelé€‰æ‹©å¼¹çª— */
       #level-select-modal {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background: rgba(0, 0, 0, 0.8);
           display: none;
           justify-content: center;
           align-items: center;
           z-index: 100;
       }

       #level-select-content {
           background: var(--panel);
           padding: 2rem;
           border-radius: 8px;
           max-width: 400px;
           width: 90%;
           max-height: 80vh;
           overflow-y: auto;
       }

       #level-select-content h3 {
           margin-top: 0;
           text-align: center;
           color: #fff;
       }

       .level-item {
           background: var(--bg);
           border: 1px solid var(--border);
           padding: 15px;
           margin: 10px 0;
           border-radius: 4px;
           cursor: pointer;
           transition: all 0.2s;
       }

       .level-item:hover {
           border-color: var(--accent);
           background: #333;
       }

       .level-difficulty {
           color: var(--accent);
           font-weight: bold;
           font-size: 1.1rem;
       }

       .level-info {
           color: #888;
           font-size: 0.9rem;
           margin-top: 5px;
       }
   </style>
</head>
<body>

   <!-- åˆå§‹åŠ è½½æç¤º -->
   <div id="loading-screen">
       <h1>æ­£åœ¨åŠ è½½å¼•æ“...</h1>
   </div>

   <!-- è®¾ç½®é¢æ¿ -->
   <div id="setup-panel">
       <h2>Milthm è°±é¢æ’­æ”¾å™¨</h2>
       
       <!-- æ–‡ä»¶é€‰æ‹© -->
       <div class="input-group">
           <label>è°±é¢æ–‡ä»¶ (JSON / ZIP)</label>
           <label class="file-btn" id="btn-chart" for="input-chart">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</label>
           <input type="file" id="input-chart" accept=".json,.zip">
       </div>

       <div class="input-group">
           <label>éŸ³é¢‘æ–‡ä»¶ (è‡ªåŠ¨è¯†åˆ«ZIPå¯è·³è¿‡)</label>
           <label class="file-btn" id="btn-audio" for="input-audio">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å¯é€‰)</label>
           <input type="file" id="input-audio" accept="audio/*">
       </div>

       <div class="input-group">
           <label>èƒŒæ™¯æ’å›¾ (è‡ªåŠ¨è¯†åˆ«ZIPå¯è·³è¿‡)</label>
           <label class="file-btn" id="btn-illu" for="input-illu">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å¯é€‰)</label>
           <input type="file" id="input-illu" accept="image/*">
       </div>

       <div class="options-row">
           <label class="checkbox-wrapper">
               <input type="checkbox" id="check-autoplay">
               <span>è‡ªåŠ¨æ¼”ç¤º (Autoplay)</span>
           </label>
       </div>

       <div id="status-msg"></div>

       <button class="btn-primary" id="btn-start" disabled>å¼€å§‹æ¸¸æˆ</button>
   </div>

   <!-- Levelé€‰æ‹©å¼¹çª— -->
   <div id="level-select-modal">
       <div id="level-select-content">
           <h3>é€‰æ‹©éš¾åº¦</h3>
           <div id="level-list"></div>
       </div>
   </div>

   <!-- æ¸¸æˆå†…åŠ è½½é®ç½© -->
   <div id="game-loading-overlay">
       <div class="spinner"></div>
       <div class="loading-text">æ­£åœ¨åˆå§‹åŒ–æ’­æ”¾å™¨...</div>
   </div>

   <!-- æ¸¸æˆæ§åˆ¶æ  -->
   <div id="game-controls">
       <button class="icon-btn" id="btn-restart" title="é‡æ–°å¼€å§‹">â†º</button>
       <button class="icon-btn" id="btn-fullscreen" title="å…¨å±">â›¶</button>
       <button class="icon-btn" id="btn-quit" title="é€€å‡º">âœ•</button>
   </div>

   <canvas id="main-canvas"></canvas>

   <!-- JSZip ç”¨äºè§£æ ZIP (CDN å¼•å…¥ï¼Œè½»é‡) -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
   
   <script>
       // --- çŠ¶æ€ç®¡ç† ---
       const state = {
           chartFile: null,
           audioFile: null,
           illuFile: null,
           isZipMode: false,
           zipFiles: null, // JSZip å¯¹è±¡
           zipType: null, // 'meta' or 'info'
           isEngineReady: false,
           playerInstance: null,
           storyboardAssets: new Map(), // é¢„åŠ è½½çš„æ•…äº‹æ¿èµ„æº name -> Image
           currentLevel: null // å½“å‰é€‰æ‹©çš„level (info.jsonæ¨¡å¼)
       };

       // --- DOM å…ƒç´  ---
       const els = {
           loading: document.getElementById('loading-screen'),
           setupPanel: document.getElementById('setup-panel'),
           gameControls: document.getElementById('game-controls'),
           gameLoadingOverlay: document.getElementById('game-loading-overlay'),
           levelModal: document.getElementById('level-select-modal'),
           levelList: document.getElementById('level-list'),
           canvas: document.getElementById('main-canvas'),
           inputs: {
               chart: document.getElementById('input-chart'),
               audio: document.getElementById('input-audio'),
               illu: document.getElementById('input-illu')
           },
           btns: {
               chart: document.getElementById('btn-chart'),
               audio: document.getElementById('btn-audio'),
               illu: document.getElementById('btn-illu'),
               start: document.getElementById('btn-start'),
               restart: document.getElementById('btn-restart'),
               fullscreen: document.getElementById('btn-fullscreen'),
               quit: document.getElementById('btn-quit')
           },
           checkAutoplay: document.getElementById('check-autoplay'),
           status: document.getElementById('status-msg')
       };

       // --- åˆå§‹åŒ–å¼•æ“ ---
       (async () => {
           try {
               // åŠ è½½å­—ä½“
               const font = new FontFace("milFont", "url(./resources/milres/milfont.ttf)");
               document.fonts.add(await font.load());

               // åŠ è½½å¼•æ“æ¨¡å— (å‡è®¾è·¯å¾„æ­£ç¡®)
               const h5bind = await import("./src/h5bind.js");
               window.MilLunePlayer = h5bind.default.MilLunePlayer;
               
               state.isEngineReady = true;
               els.loading.style.display = 'none';
               checkReady();
           } catch (e) {
               console.error(e);
               els.loading.innerHTML = `<h1>å¼•æ“åŠ è½½å¤±è´¥</h1><p style="color:#888">${e.message}</p>`;
           }
       })();

       // --- æ–‡ä»¶å¤„ç†é€»è¾‘ ---
       
       // æ›´æ–°æŒ‰é’®æ–‡æœ¬
       function updateFileBtn(btn, text, isActive = true) {
           btn.textContent = text;
           if (isActive) btn.classList.add('active');
           else btn.classList.remove('active');
       }

       // è¯»å–æ–‡ä»¶ä¸º URL
       function readFile(file) {
           return URL.createObjectURL(file);
       }

       // é¢„åŠ è½½ZIPä¸­çš„æ‰€æœ‰å›¾ç‰‡èµ„æº
       async function preloadZipImages(zip) {
           state.storyboardAssets.clear();
           const imageExts = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
           const imageFiles = [];
           
           // æ”¶é›†æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶
           zip.forEach((relativePath, file) => {
               if (!file.dir) {
                   const ext = relativePath.slice(relativePath.lastIndexOf('.')).toLowerCase();
                   if (imageExts.includes(ext)) {
                       imageFiles.push({ path: relativePath, file: file });
                   }
               }
           });

           // å¹¶è¡ŒåŠ è½½æ‰€æœ‰å›¾ç‰‡
           const loadPromises = imageFiles.map(async ({ path, file }) => {
               try {
                   const blob = await file.async('blob');
                   const url = URL.createObjectURL(blob);
                   const img = new Image();
                   
                   await new Promise((resolve, reject) => {
                       img.onload = resolve;
                       img.onerror = reject;
                       img.src = url;
                   });

                   // å­˜å‚¨ä¸å¸¦è·¯å¾„çš„æ–‡ä»¶åä½œä¸ºkey
                   const fileName = path.split('/').pop();
                   state.storyboardAssets.set(fileName.toLowerCase(), img);
                   
                   // åŒæ—¶å­˜å‚¨å¸¦è·¯å¾„çš„ç‰ˆæœ¬
                   state.storyboardAssets.set(path.toLowerCase(), img);
                   
                   return true;
               } catch (e) {
                   console.warn(`Failed to load image: ${path}`, e);
                   return false;
               }
           });

           await Promise.all(loadPromises);
           console.log(`Preloaded ${state.storyboardAssets.size} images from ZIP`);
       }

       // æ•…äº‹æ¿èµ„æºåŠ è½½å™¨
       function storyboardTextureLoader(name) {
           // æ¸…ç†åç§°
           const cleanName = name.trim();
           
           // 1. ç›´æ¥æŸ¥æ‰¾
           let img = state.storyboardAssets.get(cleanName.toLowerCase());
           if (img) return img;
           
           // 2. å¦‚æœnameæœ‰åç¼€åï¼Œç›´æ¥æœç´¢
           const hasExt = /\.(png|jpg|jpeg|gif|webp|bmp)$/i.test(cleanName);
           if (hasExt) {
               // å°è¯•å„ç§è·¯å¾„ç»„åˆ
               const variations = [
                   cleanName.toLowerCase(),
                   cleanName.split('/').pop().toLowerCase(),
                   '/' + cleanName.toLowerCase(),
                   cleanName.replace(/^\//, '').toLowerCase()
               ];
               
               for (const v of variations) {
                   img = state.storyboardAssets.get(v);
                   if (img) return img;
               }
           } else {
               // 3. æ²¡æœ‰åç¼€åï¼Œå°è¯•æ·»åŠ å¸¸è§åç¼€æœç´¢
               const exts = ['.png', '.jpg', '.jpeg', '.gif', '.webp'];
               for (const ext of exts) {
                   const nameWithExt = cleanName + ext;
                   img = state.storyboardAssets.get(nameWithExt.toLowerCase());
                   if (img) return img;
                   
                   // ä¹Ÿå°è¯•å¸¦æ–œæ çš„ç‰ˆæœ¬
                   img = state.storyboardAssets.get(('/' + nameWithExt).toLowerCase());
                   if (img) return img;
               }
           }
           
           // 4. å¯¹äºinfo.jsonæ¨¡å¼ï¼Œæ£€æŸ¥storyboard_assetsæ˜ å°„
           if (state.zipType === 'info' && state.currentLevel && state.currentLevel.FileMap) {
               const sbAssets = state.currentLevel.FileMap.storyboard_assets || {};
               if (sbAssets[cleanName]) {
                   const mappedPath = sbAssets[cleanName];
                   img = state.storyboardAssets.get(mappedPath.toLowerCase());
                   if (img) return img;
               }
           }
           
           // æ²¡æ‰¾åˆ°ï¼Œè¿”å›null
           console.warn(`Storyboard asset not found: ${name}`);
           return null;
       }

       // æ˜¾ç¤ºLevelé€‰æ‹©å¼¹çª—
       function showLevelSelect(levels) {
           return new Promise((resolve) => {
               els.levelList.innerHTML = '';
               
               levels.forEach((level, index) => {
                   const item = document.createElement('div');
                   item.className = 'level-item';
                   
                   const diff = level.Difficulty || 'Unknown';
                   const mapper = level.Beatmapper || 'Unknown';
                   const diffValue = level.DifficultyValue || 0;
                   
                   item.innerHTML = `
                       <div class="level-difficulty">${diff} ${diffValue > 0 ? diffValue.toFixed(1) : ''}</div>
                       <div class="level-info">è°±å¸ˆ: ${mapper}</div>
                   `;
                   
                   item.addEventListener('click', () => {
                       els.levelModal.style.display = 'none';
                       resolve(level);
                   });
                   
                   els.levelList.appendChild(item);
               });
               
               els.levelModal.style.display = 'flex';
           });
       }

       // è§£æ ZIP
       async function handleZip(file) {
           try {
               const zip = await JSZip.loadAsync(file);
               state.zipFiles = zip;
               
               // é¢„åŠ è½½æ‰€æœ‰å›¾ç‰‡èµ„æº
               await preloadZipImages(zip);
               
               // æ£€æŸ¥æ˜¯å¦æœ‰ meta.json
               const metaFile = zip.file("meta.json");
               if (metaFile) {
                   // meta.json æ¨¡å¼
                   const metaContent = await metaFile.async("string");
                   const meta = JSON.parse(metaContent);

                   if (!meta.chart_file) {
                       throw new Error("meta.json ä¸­ç¼ºå°‘ chart_file å­—æ®µ");
                   }

                   const getZipFile = (filename) => {
                       if (!filename) return null;
                       while (filename.length && filename[0] === ".") filename = filename.slice(1);
                       let f = zip.file(filename);
                       if (!f && filename.startsWith('/')) f = zip.file(filename.slice(1));
                       if (!f && !filename.startsWith('/')) f = zip.file('/' + filename);
                       return f;
                   };

                   const chartBlob = await getZipFile(meta.chart_file).async("blob");
                   const audioBlob = meta.audio_file ? await getZipFile(meta.audio_file).async("blob") : null;
                   const illuBlob = meta.image_file ? await getZipFile(meta.image_file).async("blob") : null;

                   state.chartFile = new File([chartBlob], meta.chart_file, {type: "application/json"});
                   state.audioFile = audioBlob ? new File([audioBlob], meta.audio_file, {type: "audio/mpeg"}) : null;
                   state.illuFile = illuBlob ? new File([illuBlob], meta.image_file, {type: "image/png"}) : null;
                   state.zipType = 'meta';
                   state.currentLevel = null;

                   updateFileBtn(els.btns.chart, `ğŸ“¦ ZIP(meta): ${file.name}`);
                   if(state.audioFile) updateFileBtn(els.btns.audio, `ğŸµ ${meta.audio_file}`);
                   if(state.illuFile) updateFileBtn(els.btns.illu, `ğŸ–¼ï¸ ${meta.image_file}`);

                   els.status.textContent = "ZIP è§£ææˆåŠŸ (meta.json)";
                   checkReady();
                   return;
               }

               // æ£€æŸ¥æ˜¯å¦æœ‰ info.json
               const infoFile = zip.file("info.json");
               if (infoFile) {
                   // info.json æ¨¡å¼
                   const infoContent = await infoFile.async("string");
                   const info = JSON.parse(infoContent);

                   if (!info.Levels || info.Levels.length === 0) {
                       throw new Error("info.json ä¸­æ²¡æœ‰ Levels");
                   }

                   state.zipType = 'info';
                   
                   // æ˜¾ç¤ºLevelé€‰æ‹©
                   const selectedLevel = await showLevelSelect(info.Levels);
                   state.currentLevel = selectedLevel;

                   // ä½¿ç”¨é€‰ä¸­çš„Level
                   const fileMap = selectedLevel.FileMap;
                   
                   // è·å–æ–‡ä»¶
                   const getFileFromMap = (path) => {
                       if (!path) return null;
                       // ç§»é™¤å¼€å¤´çš„æ–œæ 
                       const cleanPath = path.replace(/^\//, '');
                       return zip.file(cleanPath) || zip.file(path);
                   };

                   const chartZipFile = getFileFromMap(fileMap.beatmap);
                   const audioZipFile = fileMap.song && fileMap.song.length > 0 ? 
                       getFileFromMap(fileMap.song[0].file) : null;
                   const illuZipFile = getFileFromMap(fileMap.illu);

                   if (!chartZipFile) {
                       throw new Error("æ‰¾ä¸åˆ°è°±é¢æ–‡ä»¶: " + fileMap.beatmap);
                   }

                   const chartBlob = await chartZipFile.async("blob");
                   const audioBlob = audioZipFile ? await audioZipFile.async("blob") : null;
                   const illuBlob = illuZipFile ? await illuZipFile.async("blob") : null;

                   state.chartFile = new File([chartBlob], "beatmap.json", {type: "application/json"});
                   state.audioFile = audioBlob ? new File([audioBlob], "song.ogg", {type: "audio/ogg"}) : null;
                   state.illuFile = illuBlob ? new File([illuBlob], "illu.png", {type: "image/png"}) : null;

                   updateFileBtn(els.btns.chart, `ğŸ“¦ ZIP(info): ${file.name} [${selectedLevel.Difficulty}]`);
                   if(state.audioFile) updateFileBtn(els.btns.audio, `ğŸµ audio`);
                   if(state.illuFile) updateFileBtn(els.btns.illu, `ğŸ–¼ï¸ illu`);

                   els.status.textContent = `å·²é€‰æ‹©: ${selectedLevel.Difficulty}`;
                   checkReady();
                   return;
               }

               throw new Error("ZIPä¸­æ—¢æ²¡æœ‰ meta.json ä¹Ÿæ²¡æœ‰ info.json");

           } catch (err) {
               els.status.textContent = "ZIP é”™è¯¯: " + err.message;
               console.error(err);
               resetFiles();
           }
       }

       function resetFiles() {
           state.chartFile = null;
           state.audioFile = null;
           state.illuFile = null;
           state.isZipMode = false;
           state.zipType = null;
           state.zipFiles = null;
           state.currentLevel = null;
           state.storyboardAssets.clear();
           els.inputs.chart.value = '';
           els.inputs.audio.value = '';
           els.inputs.illu.value = '';
           updateFileBtn(els.btns.chart, "ç‚¹å‡»é€‰æ‹©æ–‡ä»¶", false);
           updateFileBtn(els.btns.audio, "ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å¯é€‰)", false);
           updateFileBtn(els.btns.illu, "ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å¯é€‰)", false);
       }

       // äº‹ä»¶ç›‘å¬
       els.inputs.chart.addEventListener('change', async (e) => {
           const file = e.target.files[0];
           if (!file) return;

           if (file.name.endsWith('.zip')) {
               await handleZip(file);
           } else {
               state.chartFile = file;
               state.isZipMode = false;
               state.zipType = null;
               state.storyboardAssets.clear();
               updateFileBtn(els.btns.chart, `ğŸ“„ ${file.name}`);
               checkReady();
           }
       });

       els.inputs.audio.addEventListener('change', (e) => {
           if (state.isZipMode) return; // ZIPæ¨¡å¼ä¸‹å¿½ç•¥å•ç‹¬é€‰æ‹©
           const file = e.target.files[0];
           if (file) {
               state.audioFile = file;
               updateFileBtn(els.btns.audio, `ğŸµ ${file.name}`);
           }
       });

       els.inputs.illu.addEventListener('change', (e) => {
           if (state.isZipMode) return;
           const file = e.target.files[0];
           if (file) {
               state.illuFile = file;
               updateFileBtn(els.btns.illu, `ğŸ–¼ï¸ ${file.name}`);
           }
       });

       function checkReady() {
           const ready = state.isEngineReady && state.chartFile;
           els.btns.start.disabled = !ready;
           if(ready) els.status.textContent = "";
       }

       // --- æ¸¸æˆæ§åˆ¶é€»è¾‘ ---

       async function startGame() {
           if (!state.chartFile) return;

           // æ˜¾ç¤ºåŠ è½½é®ç½©
           els.gameLoadingOverlay.style.display = 'flex';
           
           // ç»™UIæ—¶é—´æ¸²æŸ“é®ç½©
           await new Promise(resolve => setTimeout(resolve, 50));

           try {
               // åœæ­¢æ—§å®ä¾‹
               if (state.playerInstance) {
                   if (typeof state.playerInstance.stop === 'function') {
                       state.playerInstance.stop();
                   }
                   if (state.playerInstance.destroy) {
                       state.playerInstance.destroy();
                   }
                   state.playerInstance = null;
               }

               // éšè—è®¾ç½®ï¼Œæ˜¾ç¤ºç”»å¸ƒ
               els.setupPanel.style.display = 'none';
               els.gameControls.style.display = 'flex';
               els.canvas.style.display = 'block';
               
               // è°ƒæ•´ç”»å¸ƒå¤§å°
               resizeCanvas();
               window.addEventListener('resize', resizeCanvas);

               // åˆ›å»º URL
               const chartUrl = readFile(state.chartFile);
               const audioUrl = state.audioFile ? readFile(state.audioFile) : null;
               const illuUrl = state.illuFile ? readFile(state.illuFile) : null;

               state.playerInstance = new window.MilLunePlayer({
                   buildDirectory: "./build/",
                   resourcePackPath: "./resources/milres/default.mrp",
                   canvas: els.canvas,
                   chartPath: chartUrl,
                   audioPath: audioUrl,
                   illuPath: illuUrl,
                   fontFam: "milFont",
                   pauseBtnPath: "./resources/milres/buttons/light/pause.png",
                   storyboardTextureLoader: storyboardTextureLoader,
                   isAutoplay: els.checkAutoplay.checked
               });

               await state.playerInstance.init();
               
               // éšè—åŠ è½½é®ç½©
               els.gameLoadingOverlay.style.display = 'none';

               // å°è¯•å…¨å± (ç”¨æˆ·æ‰‹åŠ¿è§¦å‘)
               if (document.body.requestFullscreen) {
                   document.body.requestFullscreen().catch(e => console.log("Fullscreen denied"));
               }

               state.playerInstance.start();

               const renderLoop = () => {
                   if (state.playerInstance) {
                       state.playerInstance.render();
                       requestAnimationFrame(renderLoop);
                   }
               };
               renderLoop();

           } catch (err) {
               console.error(err);
               els.gameLoadingOverlay.style.display = 'none';
               alert("å¯åŠ¨å¤±è´¥: " + err.message);
               quitGame();
           }
       }

       function resizeCanvas() {
           els.canvas.width = window.innerWidth;
           els.canvas.height = window.innerHeight;
       }

       function quitGame() {
           // åœæ­¢æ’­æ”¾å™¨
           if (state.playerInstance) {
               if (typeof state.playerInstance.stop === 'function') {
                   state.playerInstance.stop();
               }
               if (state.playerInstance.destroy) {
                   state.playerInstance.destroy();
               }
               state.playerInstance = null;
           }
           
           // æ¸…ç†èµ„æºURL
           // (ç®€å•å¤„ç†ï¼šå¦‚æœé‡æ–°é€‰æ‹©æ–‡ä»¶ä¼šè‡ªåŠ¨è¦†ç›–ï¼Œè¿™é‡Œä¸é€ä¸ªè¿½è¸ª revoke)

           els.canvas.style.display = 'none';
           els.gameControls.style.display = 'none';
           els.gameLoadingOverlay.style.display = 'none';
           els.setupPanel.style.display = 'flex';
           window.removeEventListener('resize', resizeCanvas);
           
           if (document.fullscreenElement) {
               document.exitFullscreen();
           }
       }

       // æŒ‰é’®ç»‘å®š
       els.btns.start.addEventListener('click', startGame);
       
       els.btns.restart.addEventListener('click', () => {
           // é‡æ–°å¼€å§‹å³é‡æ–°å®ä¾‹åŒ–ï¼Œä¼šå…ˆè°ƒç”¨stop()
           startGame();
       });

       els.btns.quit.addEventListener('click', quitGame);

       els.btns.fullscreen.addEventListener('click', () => {
           if (!document.fullscreenElement) {
               document.body.requestFullscreen();
           } else {
               document.exitFullscreen();
           }
       });

   </script>
</body>
</html>